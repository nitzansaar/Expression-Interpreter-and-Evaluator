### Assignment 5: Lexer, Parser, Interpreter

##### Due Monday 11/14 at the start of class.

This homework will be graded using specifications grading. There are a sequence of tasks to complete. Grades will be assigned as follows:

    To receive a C, you should complete tasks 1-4 and 6
    To receive a B, complete all the C-level tasks, plus tasks 5,7 and 8.
    To receive an A, complete the B-level tasks, plus task 9.


In this project, you'll be integrating several concepts that you've learned about this semester to implement an interpreter that can read and evaluate inputs. You will:

- see how to use Stacks, Trees, Lists and HashMaps in a larger program
- Learn how to tokenize, parse and evaluate sentences in a high-level language

Advice:

Build this incrementally. Start small, and be diligent about unit testing as you go. There are lots of interlocking pieces. The debugger is also very helpful for this project.
 I've provided some skeleton code to help guide you through this.
 
 
Refer to the lecture slides as well for details.

Terminology:
- A term is a single number or variable.
- An expression is a set of numbers, identifiers and operators organized in a legal way.
For example:
  - 4 + 3
  - x - y * z + 1
  - 3 - x + x * y + 4

- An assignment is a statement with an expression on the right-hand side and an identifier on the left.
- For example:
  - x = 4
  - y = 3 * z - 1
  - y = y + 3 - x
  
Part 1: Lexer.

A lexer is a tool that takes a String as input and emits a list of Tokens. (I've provided the Token class for you.)

A Token has a type and a value. Our language has the following Tokens:

- Integers: At least one digit in a row.
- Floats: One or more digits, followed by ., followed by more digits.
- Identifiers. A letter, followed by letters or numbers.
- Operators: +, -, *, /
- Assignment: =
- Expression assignment: #


Tokens can have whitespace between them, but it's not required.

Task 1: Implement the methods in Lexer so that getAllTokens repeatedly calls getNextToken, which  looks at the current position in the input buffer, determines what token is next, and calls the appropriate method. It should return a list of Tokens. If the input is invalid, throw an 
IllegalArgumentException and indicate where the lexer stopped. Please note that the Lexer is not trying to determine whether an expression is valid; just generating tokens.
 
 Part 2: Expression Tree. 
 
 Note: this is the most complex part of the project. Start by just parsing expressions, then work on the interpreter. That will help you see how it all fits together. Then back up and worry about handling assignments.
 
 The expression tree is a data structure that stores a computation. Leaves contain numbers or variables, and parent nodes contain operators. We can compute the result by doing a postorder traversal.
 
 Task 2: Start by implementing parseNumber and parseIdentifier, using parseOperator as an example. They should all take a Token (generated by the Lexer) as input and return a Node. If they get unexpected input, they should throw an IllegalArgumentException indicating a parse error, and the token being processed. You should be using jUnit as you go to convince yourself that each of these work correctly.
 
Task 3:  Next, implement parseExpression. Use the shunting yard algorithm presented in the lecture slides to construct an expression tree, calling the methods you just implemented. Throw an IllegalArgumentEception indicating a parse error and the token being processed if the input is invalid. Again, use JUnit to convince yourself that this is working.
 
Task 4: Next, implement evaluate. This should do a postorder traversal of the tree - each operator node should evaluate its left branch, evaluate its right branch, apply the operator, and return the result. Leaves should either return their value (if they're a number) or look up their value in the Symbol Table (if they're an identifier.) Again, test with JUnit.
 
(at this point, you might want to jump to part 3, get the basic shell running, and try it out.)
 
Task 5: Next, implement parseAssignment. Parse the identifier and assignment operator, parse the expression on the right-hand side, evaluate it, and store the result in the Symbol Table.
 
Part 3: Interpreter:
 
 The interpreter is the engine that runs everything. It should be able to either:

Task 6: prompt the user for input, read in a string, run it through the lexer, then parse it and display the result. 
Task 7: Read a series of sentences from a file and sequentially parse them and display their results.
 

Task 8: It should have a verbose mode that displays input and output, along with the symbol table. This will be helpful for debugging.
 
 Part 4: Expression assignment.
 
 A cool feature of expression trees is the fact tht they're both code and data. We'll use this to store them as a function and execute them later.
 
Task 9: Implement the parseExprAssignment method. Like parseAssignment, it should grab the identifer, parse the exprAssignment operator, and then parse the expression on the right-hand side. But, rather than evaluating it, you should store the expression tree in the Symbol Table.
 Then, modify evaluate() so that when that identifier is evaluated, the corresponding expression tree is fetched from the symbol table and evaluated.
   
